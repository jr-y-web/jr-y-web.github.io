import{_ as s,v as a,b as n,R as o}from"./chunks/framework.6f86f316.js";const C=JSON.parse('{"title":"模块化","description":"","frontmatter":{},"headers":[],"relativePath":"serve/nodejs/modularity.md","filePath":"serve/nodejs/modularity.md","lastUpdated":1693397352000}'),l={name:"serve/nodejs/modularity.md"},p=o(`<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h1><p>Node.js 模块化规范遵循两套规范，分别为<code>commonJS</code> 与 <code>esm</code>(Es6)规范。</p><ul><li>commonJS 规范： 该规范是自 nodejs 创建以来，一直使用的基于传统模块化的格式</li><li>esm 规范： (Es6， 下文一律称呼为 Es6) 使用新的&quot;import&quot; 关键字来定义模块</li></ul><h2 id="commonjs" tabindex="-1">commonJS <a class="header-anchor" href="#commonjs" aria-label="Permalink to &quot;commonJS&quot;">​</a></h2><p>CommonJS 是使用<code>module.export</code>来导出 JS 模块，举个例子现在导出一个 fn 方法:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...功能逻辑</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">module.</span><span style="color:#A6ACCD;">export </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  fn</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span></code></pre></div><p>如何引入，则使用 require 来使用上述模块，举个例子它叫 index.ts：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">require</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./index.ts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span></code></pre></div><h2 id="es6" tabindex="-1">Es6 <a class="header-anchor" href="#es6" aria-label="Permalink to &quot;Es6&quot;">​</a></h2><p>而 Es6 的导出模块则相对来说简略了不少， Es6 是使用 export 导出，方法就是将 export 放置在任意变量，函数或者类声明之前：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 导出函数</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...功能逻辑</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">//导出变量</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> list </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>其中，除了 export 关键词之外，每个声明都与正式形式完全一样，每个被导出的函数或者类都有名称，这是因为导出的函数声明与类声明必须要有名称，不能使用这种语法导出匿名。 同时，Es6 还提供<code>export default</code>来导出模块，它和正常在一个文件里面对某个方法或者变量的<code>export</code>导出的区别为：</p><ul><li><code>export default</code> 是向外暴露成员，可以使用任意变量来接受，但是<code>export</code>只能用已导出的名称进行接收。必须严格按照导出时候的名称，来使用{ }按需接收。</li><li>在一个模块中 <code>export default</code> 只允许向外暴露一次,<code>export</code>则可以多次。</li></ul><p>当然它们也可以混合使用：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> fn </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// ...功能逻辑</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> list </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> []</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">export</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">default</span><span style="color:#A6ACCD;"> fn</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>引入的时候则分开写即可：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> fn</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">list</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./index</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>特别的，在 import 引入的时候，能对引入的方法做一次重命名的操作，举个例子：</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">fn</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">getFuntions</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">./index.ts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 导出的全部都统一为echarts</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">import</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;font-style:italic;">as</span><span style="color:#A6ACCD;"> echarts </span><span style="color:#89DDFF;font-style:italic;">from</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">echarts</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">;</span></span></code></pre></div><p>这样 fn 方法就被重命名为 getFuntions, 另一个带<code>*</code>号则是代表导出的全部都为 xxx。</p><h2 id="es6-与-commonjs-的区别" tabindex="-1">Es6 与 commonJS 的区别 <a class="header-anchor" href="#es6-与-commonjs-的区别" aria-label="Permalink to &quot;Es6 与 commonJS 的区别&quot;">​</a></h2><ul><li>commonJS 是基于运行时的同步加载，Es6 是基于编译时的异步加载</li><li>commonJS 是可以修改值的，Es6 值并且不可修改（可读的）</li><li>commonJS 不可以 tree shaking，Es6 支持 tree shaking</li><li>commonjs 中顶层的 this 指向这个模块本身，而 ES6 中顶层 this 指向 undefined</li></ul><div class="warning custom-block"><p class="custom-block-title">WARNING</p><p>特别注意，commonJS 是可以引入<code>.json</code>文件的，但是 Es6 的 import 是不可以引入<code>.json</code>文件的，但这个问题大多数被当前框架所兼容，比如 vite 就兼容了引入<code>.json</code>文件，使得使用 vite 开发时候，可以直接<code>import data from &#39;./index.json&#39;</code>。</p></div><h2 id="node-js-核心模块" tabindex="-1">node.js 核心模块 <a class="header-anchor" href="#node-js-核心模块" aria-label="Permalink to &quot;node.js 核心模块&quot;">​</a></h2><p>核心模块为 Node.js 提供了最基本的 Api,这些核心模块被编译为二进制分发，并在 Node.js 进程启动时自动加载，常用的核心模块如下：</p><ul><li><code>buffer</code> 用于二进制数据的处理</li><li><code>events</code> 用于事件处理</li><li><code>fs</code> 用于与文件系统交互</li><li><code>http</code> 用于提供 http 服务器和客户端</li><li><code>net</code> 提供异步网络 api，用于创建基于流的 TCP 或 IPC 服务器和客户端</li><li><code>path</code> 用于处理文件和目录的路径</li><li><code>tls</code> 提供了基于 OpenSSL 构建的传输安全性(TLS)和</li><li><code>dgram</code> 提供了 UDP 数据报台接字的实现</li></ul><p>后续将对这几个模块，进行大量的分析和学习</p>`,27),e=[p];function t(c,r,i,D,y,d){return a(),n("div",null,e)}const A=s(l,[["render",t]]);export{C as __pageData,A as default};
